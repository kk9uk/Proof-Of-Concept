## Arrays & Hashing
- HashSet/Map for seen/count

## Binary Search
- cut search space
- [l, ..., m, ..., r]: either l..=m or m..=r sorted

## Heap
- min/max heap for kth largest/smallest

## Sliding Window
- grow & shrink

## Stack
- LIFO
- isEmpty()?

## Two Pointer
- while (l < r)

## Backtracking
- make a decision
- for i = currI
  - add
  - subproblem()
  - remove

## Linked List
- FIFO
- fast & slow ptr

## Tree
- subproblem(subtree)

## Trie

## Greedy
- forward/backward
- look for better

## Interval
- non-overlapping: (new.end < old.start) || (old.end < new.start)
- sort by start?

## Dynamic Programming
- spot the recursive structure (what are the variables?)
- solve the subproblems in a topological order
- memorize results to avoid recomputing

## Graph
- be careful...